// ------------------------------------------
// PBKDF2 Key Derivation
// ------------------------------------------
async function deriveKey(password, salt) {
    // Convert password + salt to ArrayBuffers
    const enc = new TextEncoder();
    const passBuf = enc.encode(password);

    // Import "raw" key from password bytes
    const baseKey = await crypto.subtle.importKey("raw", passBuf, { name: "PBKDF2" }, false, ["deriveKey"]);

    // Derive a 256-bit AES-GCM key
    return crypto.subtle.deriveKey(
        {
            name: "PBKDF2",
            salt: salt,
            iterations: 100000,
            hash: "SHA-256",
        },
        baseKey,
        { name: "AES-GCM", length: 256 },
        false,
        ["encrypt", "decrypt"]
    );
}

// ------------------------------------------
// Encryption with AES-GCM
// ------------------------------------------
async function encryptData(plaintext, password) {
    let autoGenerated = false;

    // If no password is provided, generate a random one
    if (!password) {
        password = generateRandomPassword();
        autoGenerated = true;
    }

    // Generate random salt for PBKDF2
    const salt = crypto.getRandomValues(new Uint8Array(16));
    const aesKey = await deriveKey(password, salt);

    // Generate random IV
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const enc = new TextEncoder();
    const plaintextBuf = enc.encode(plaintext);

    // Encrypt using AES-GCM
    const ciphertextBuf = await crypto.subtle.encrypt({ name: "AES-GCM", iv: iv }, aesKey, plaintextBuf);

    // Convert buffers to Base64
    return {
        encryptedObj: {
            salt: btoa(String.fromCharCode(...salt)),
            iv: btoa(String.fromCharCode(...iv)),
            ciphertext: btoa(String.fromCharCode(...new Uint8Array(ciphertextBuf))),
        },
        generatedPassword: autoGenerated ? password : null, // Send the generated password if one was created
    };
}

// Generates a 16-character random password
function generateRandomPassword() {
    return window.crypto
        .getRandomValues(new Uint8Array(16))
        .map((byte) => ("0" + byte.toString(16)).slice(-2)) // Convert each byte to hex
        .join("");
}

// Re-use the same logic as encryption but in reverse
async function backwardsDeriveKey(password, saltBuf) {
    const enc = new TextEncoder();
    const passBuf = enc.encode(password);

    const baseKey = await crypto.subtle.importKey("raw", passBuf, { name: "PBKDF2" }, false, ["deriveKey"]);

    return crypto.subtle.deriveKey(
        {
            name: "PBKDF2",
            salt: saltBuf,
            iterations: 100000,
            hash: "SHA-256",
        },
        baseKey,
        { name: "AES-GCM", length: 256 },
        false,
        ["encrypt", "decrypt"]
    );
}

async function decryptData({ salt, iv, ciphertext }, password) {
    // Convert base64 back to ArrayBuffer
    const saltBuf = Uint8Array.from(atob(salt), (c) => c.charCodeAt(0));
    const ivBuf = Uint8Array.from(atob(iv), (c) => c.charCodeAt(0));
    const ctBuf = Uint8Array.from(atob(ciphertext), (c) => c.charCodeAt(0));

    // Derive the same AES-GCM key
    const aesKey = await backwardsDeriveKey(password, saltBuf);

    const decryptedBuf = await crypto.subtle.decrypt(
        {
            name: "AES-GCM",
            iv: ivBuf,
        },
        aesKey,
        ctBuf
    );

    return new TextDecoder().decode(decryptedBuf);
}

export { encryptData, decryptData };